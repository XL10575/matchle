import java.util.Comparator;
import java.util.Objects;
import java.util.function.ToLongFunction;

public class MatchleScorer {
    private final Corpus corpus;

    public MatchleScorer(Corpus corpus) {
        // Defensive check: ensure corpus is not null and not empty.
        this.corpus = Objects.requireNonNull(corpus, "Corpus must not be null");
        if (this.corpus.size() == 0) {
            throw new IllegalArgumentException("Corpus must not be empty");
        }
    }

    /**
     * Computes the score for a given key/guess pair using a parallel stream.
     * The score is defined as the count of NGrams in the corpus that are consistent
     * with the feedback filter generated by comparing the key and guess.
     *
     * @param key   the target NGram
     * @param guess the guessed NGram
     * @return the score as a long value
     * @throws NullPointerException if key or guess is null
     */
    public long score(NGram key, NGram guess) {
        Objects.requireNonNull(key, "Key cannot be null");
        Objects.requireNonNull(guess, "Guess cannot be null");
        // Generate the feedback Filter from comparing key and guess.
        Filter feedback = NGramMatcher.of(key, guess).match();
        // Count in parallel how many NGrams in the corpus match the filter.
        return corpus.corpus().parallelStream()
                     .filter(feedback::test)
                     .count();
    }

    /**
     * Computes the worst-case score for a given guess, defined as the maximum
     * score over all possible keys in the corpus.
     *
     * @param guess the guessed NGram
     * @return the worst-case score
     * @throws NullPointerException if guess is null
     */
    public long scoreWorstCase(NGram guess) {
        Objects.requireNonNull(guess, "Guess cannot be null");
        return corpus.corpus().parallelStream()
                     .mapToLong(key -> score(key, guess))
                     .max()
                     .orElseThrow(() -> new IllegalStateException("Unexpected: corpus is non-empty"));
    }

    /**
     * Computes the average-case score for a given guess, defined as the sum of the scores
     * over all keys in the corpus.
     *
     * @param guess the guessed NGram
     * @return the average-case score
     * @throws NullPointerException if guess is null
     */
    public long scoreAverageCase(NGram guess) {
        Objects.requireNonNull(guess, "Guess cannot be null");
        return corpus.corpus().parallelStream()
                     .mapToLong(key -> score(key, guess))
                     .sum();
    }

    /**
     * Finds and returns the NGram from the corpus that minimizes the given scoring criterion.
     *
     * @param criterion a ToLongFunction that defines the score for a guess
     * @return the best guess NGram or null if none found
     * @throws NullPointerException if criterion is null
     */
    public NGram bestGuess(ToLongFunction<NGram> criterion) {
        Objects.requireNonNull(criterion, "Criterion cannot be null");
        return corpus.corpus().parallelStream()
                     .min(Comparator.comparingLong(criterion))
                     .orElse(null);
    }

    /**
     * Returns the best guess according to worst-case scoring.
     *
     * @return the best NGram guess minimizing the worst-case score
     */
    public NGram bestWorstCaseGuess() {
        return bestGuess(this::scoreWorstCase);
    }

    /**
     * Returns the best guess according to average-case scoring.
     *
     * @return the best NGram guess minimizing the average-case score
     */
    public NGram bestAverageCaseGuess() {
        return bestGuess(this::scoreAverageCase);
    }
}
